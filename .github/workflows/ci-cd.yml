name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]
  workflow_dispatch:

env:
  ACR_LOGIN_SERVER: ${{ secrets.ACR_LOGIN_SERVER }}
  AKS_CLUSTER_NAME: ${{ secrets.AKS_CLUSTER_NAME }}
  AKS_RESOURCE_GROUP: ${{ secrets.AKS_RESOURCE_GROUP }}

jobs:
  # Job 1: Build and Test
  build-and-test:
    name: Build and Test Services
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '18'

    - name: Install dependencies
      run: |
        npm install
        cd shared && npm install
        cd ../services/auth-service && npm install
        cd ../user-service && npm install
        cd ../group-service && npm install
        cd ../chat-service && npm install
        cd ../../frontend && npm install

    - name: Generate Prisma Client
      run: cd shared && npx prisma generate

    - name: Run linting
      run: |
        echo "Running ESLint..."
        # Add npm run lint when configured

    - name: Run tests
      run: |
        echo "Running tests..."
        # Add npm test when configured

    - name: Build frontend
      run: cd frontend && npm run build

    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: build-artifacts
        path: |
          services/*/
          frontend/dist/
          shared/
        retention-days: 1

  # Job 2: Build and Push Docker Images
  build-images:
    name: Build and Push Docker Images
    runs-on: ubuntu-latest
    needs: build-and-test
    if: github.event_name == 'push' && github.ref == 'refs/heads/main'
    
    strategy:
      matrix:
        service: [auth-service, user-service, group-service, chat-service, frontend]
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Log in to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Log in to ACR
      run: |
        az acr login --name ${{ secrets.ACR_NAME }}

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Build and push ${{ matrix.service }}
      run: |
        if [ "${{ matrix.service }}" = "frontend" ]; then
          docker build -t ${{ env.ACR_LOGIN_SERVER }}/${{ matrix.service }}:${{ github.sha }} \
                       -t ${{ env.ACR_LOGIN_SERVER }}/${{ matrix.service }}:latest \
                       -f frontend/Dockerfile ./frontend
        else
          docker build -t ${{ env.ACR_LOGIN_SERVER }}/${{ matrix.service }}:${{ github.sha }} \
                       -t ${{ env.ACR_LOGIN_SERVER }}/${{ matrix.service }}:latest \
                       -f services/${{ matrix.service }}/Dockerfile .
        fi
        
        docker push ${{ env.ACR_LOGIN_SERVER }}/${{ matrix.service }}:${{ github.sha }}
        docker push ${{ env.ACR_LOGIN_SERVER }}/${{ matrix.service }}:latest

    - name: Scan image for vulnerabilities
      run: |
        echo "Scanning ${{ matrix.service }} for vulnerabilities..."
        # Add security scanning (e.g., Trivy)
        # docker run aquasec/trivy image ${{ env.ACR_LOGIN_SERVER }}/${{ matrix.service }}:${{ github.sha }}

  # Job 3: Deploy to Development
  deploy-dev:
    name: Deploy to Development
    runs-on: ubuntu-latest
    needs: build-images
    environment:
      name: development
      url: https://dev.studysphere.example.com
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Log in to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Set AKS context
      uses: azure/aks-set-context@v3
      with:
        resource-group: ${{ env.AKS_RESOURCE_GROUP }}
        cluster-name: ${{ env.AKS_CLUSTER_NAME }}

    - name: Create namespace if not exists
      run: |
        kubectl apply -f k8s/namespaces.yaml

    - name: Create/Update secrets
      run: |
        kubectl create secret generic azure-secrets \
          --from-literal=DATABASE_URL='${{ secrets.DATABASE_URL }}' \
          --from-literal=JWT_SECRET='${{ secrets.JWT_SECRET }}' \
          --from-literal=GEMINI_API_KEY='${{ secrets.GEMINI_API_KEY }}' \
          --from-literal=GEMINI_MODEL='${{ secrets.GEMINI_MODEL }}' \
          --from-literal=AZURE_MODERATOR_KEY='${{ secrets.AZURE_MODERATOR_KEY }}' \
          --from-literal=AZURE_MODERATOR_ENDPOINT='${{ secrets.AZURE_MODERATOR_ENDPOINT }}' \
          -n development \
          --dry-run=client -o yaml | kubectl apply -f -

    - name: Deploy to Development
      run: |
        # Create temporary deployment files for development
        mkdir -p k8s-dev
        
        # Copy and modify deployments for development
        for file in k8s/deployments/*.yaml; do
          cat $file | sed "s|:latest|:${{ github.sha }}|g" | sed "s|namespace: production|namespace: development|g" > k8s-dev/$(basename $file)
        done
        
        # Copy and modify services for development
        for file in k8s/services/*.yaml; do
          cat $file | sed "s|namespace: production|namespace: development|g" > k8s-dev/$(basename $file)-service
        done
        
        kubectl apply -f k8s-dev/ -n development
        
    - name: Verify deployment
      run: |
        kubectl rollout status deployment/auth-service -n development
        kubectl rollout status deployment/user-service -n development
        kubectl rollout status deployment/group-service -n development
        kubectl rollout status deployment/chat-service -n development
        kubectl rollout status deployment/frontend -n development

    - name: Run smoke tests
      run: |
        echo "Running smoke tests..."
        # Add smoke tests

  # Job 4: Deploy to Testing (Manual Approval)
  deploy-test:
    name: Deploy to Testing
    runs-on: ubuntu-latest
    needs: deploy-dev
    environment:
      name: testing
      url: https://test.studysphere.example.com
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Log in to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Set AKS context
      uses: azure/aks-set-context@v3
      with:
        resource-group: ${{ env.AKS_RESOURCE_GROUP }}
        cluster-name: ${{ env.AKS_CLUSTER_NAME }}

    - name: Deploy to Testing
      run: |
        # Create temporary deployment files for testing
        mkdir -p k8s-test
        
        # Copy and modify deployments for testing
        for file in k8s/deployments/*.yaml; do
          cat $file | sed "s|:latest|:${{ github.sha }}|g" | sed "s|namespace: production|namespace: testing|g" > k8s-test/$(basename $file)
        done
        
        # Copy and modify services for testing
        for file in k8s/services/*.yaml; do
          cat $file | sed "s|namespace: production|namespace: testing|g" > k8s-test/$(basename $file)
        done
        
        kubectl apply -f k8s-test/ -n testing

    - name: Run integration tests
      run: |
        echo "Running integration tests..."
        # Add integration tests

  # Job 5: Deploy to Production (Manual Approval)
  deploy-prod:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: deploy-test
    environment:
      name: production
      url: https://studysphere.example.com
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Log in to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Set AKS context
      uses: azure/aks-set-context@v3
      with:
        resource-group: ${{ env.AKS_RESOURCE_GROUP }}
        cluster-name: ${{ env.AKS_CLUSTER_NAME }}

    - name: Create/Update production secrets
      run: |
        kubectl create secret generic azure-secrets \
          --from-literal=DATABASE_URL='${{ secrets.DATABASE_URL }}' \
          --from-literal=JWT_SECRET='${{ secrets.JWT_SECRET }}' \
          --from-literal=GEMINI_API_KEY='${{ secrets.GEMINI_API_KEY }}' \
          --from-literal=GEMINI_MODEL='gemini-2.0-flash-exp' \
          --from-literal=AZURE_MODERATOR_KEY='${{ secrets.AZURE_MODERATOR_KEY }}' \
          --from-literal=AZURE_MODERATOR_ENDPOINT='${{ secrets.AZURE_MODERATOR_ENDPOINT }}' \
          -n production \
          --dry-run=client -o yaml | kubectl apply -f -

    - name: Deploy to Production
      run: |
        # Create temporary deployment files for production
        mkdir -p k8s-prod
        
        # Copy and modify deployments for production (use commit SHA)
        for file in k8s/deployments/*.yaml; do
          cat $file | sed "s|:latest|:${{ github.sha }}|g" > k8s-prod/$(basename $file)
        done
        
        # Copy services and ingress as-is
        cp k8s/services/*.yaml k8s-prod/
        cp k8s/ingress.yaml k8s-prod/
        
        # Apply to production
        kubectl apply -f k8s-prod/ -n production

    - name: Verify production deployment
      run: |
        kubectl rollout status deployment/auth-service -n production
        kubectl rollout status deployment/user-service -n production
        kubectl rollout status deployment/group-service -n production
        kubectl rollout status deployment/chat-service -n production
        kubectl rollout status deployment/frontend -n production

    - name: Health checks
      run: |
        echo "Running production health checks..."
        # Add health checks

    - name: Notify deployment success
      run: |
        echo "âœ… Production deployment successful!"
        echo "Commit: ${{ github.sha }}"
        echo "Deployed by: ${{ github.actor }}"

